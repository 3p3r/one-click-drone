'use strict';

const cdk = require('@aws-cdk/core');
const ecs = require('@aws-cdk/aws-ecs');
const cfr = require('@aws-cdk/aws-cloudfront');
const ecsPatterns = require('@aws-cdk/aws-ecs-patterns');

// eslint-disable-next-line no-unused-vars
const { Database } = require('./database');
// eslint-disable-next-line no-unused-vars
const { IAMBucket } = require('./iamBucket');
// eslint-disable-next-line no-unused-vars
const { Networking } = require('./networking');
const { RemoveConstructsWithPredicate } = require('./aspects');

class DroneServer extends cdk.Construct {
  /** @param {{database:Database, logsBucket:IAMBucket, networking:Networking=, parameters:Parameters=}} props */
  constructor(scope, props, id = 'DronerServer') {
    super(scope, id);

    // Fleet of server instances, running on Fargate
    const server = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'ServerAgents', {
      cluster: props.networking.cluster,
      publicLoadBalancer: true,
      taskImageOptions: {
        image: ecs.ContainerImage.fromRegistry(props.parameters.ServerContainer.valueAsString),
        environment: {
          AWS_ACCESS_KEY_ID: props.logsBucket.accessKey,
          AWS_SECRET_ACCESS_KEY: props.logsBucket.secretKey,
          AWS_DEFAULT_REGION: this.region,
          AWS_REGION: this.region,
          DRONE_S3_BUCKET: props.logsBucket.bucketName,
          DRONE_LOGS_DEBUG: 'true',
          DRONE_LOGS_COLOR: 'false',
          DRONE_AGENTS_ENABLED: 'true',
          DRONE_REPOSITORY_FILTER: props.parameters.ServerRepoFilter,
          DRONE_GITHUB_SERVER: props.parameters.GithubServer,
          DRONE_GITHUB_CLIENT_ID: props.parameters.GithubClientId,
          DRONE_GITHUB_CLIENT_SECRET: props.parameters.GithubClientSecret,
          DRONE_RPC_SECRET: props.parameters.ServerRpcSecret,
          DRONE_DATABASE_DRIVER: 'postgres',
          DRONE_DATABASE_SECRET: props.parameters.DatabaseSecret,
          DRONE_DATABASE_DATASOURCE: cdk.Fn.sub('postgres://${user}:${pass}@${host}:${port}/drone?sslmode=disable', {
            user: props.parameters.DatabaseUsername,
            pass: props.parameters.DatabasePassword,
            host: props.database.host,
            port: props.database.port,
          }),
          DRONE_COOKIE_SECRET: props.parameters.ServerCookieSecret,
          DRONE_USER_CREATE: cdk.Fn.sub('username:${admin},admin:true', {
            admin: props.parameters.ServerAdmin,
          }),
        },
      },
    });

    // Scale server based on 90% cpu utilization
    server.service
      .autoScaleTaskCount({ maxCapacity: props.parameters.ServerMaxCapacity })
      .scaleOnCpuUtilization('ServerCPUScaling', {
        targetUtilizationPercent: 90,
        scaleInCooldown: cdk.Duration.minutes(1),
        scaleOutCooldown: cdk.Duration.minutes(1),
      });

    // We don't need CfnOutputs generated by this construct
    server.node.applyAspect(new RemoveConstructsWithPredicate(node => node instanceof cdk.CfnOutput));

    // Put CloudFront in front of Drone to add HTTPS to it and cache its frontend files
    const cloudFront = new cfr.CloudFrontWebDistribution(this, 'CloudfrontWrapper', {
      viewerProtocolPolicy: cfr.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      originConfigs: [
        {
          customOriginSource: {
            domainName: server.loadBalancer.loadBalancerDnsName,
            originProtocolPolicy: cfr.OriginProtocolPolicy.HTTP_ONLY,
            allowedOriginSSLVersions: [
              cfr.OriginSslPolicy.TLS_V1,
              cfr.OriginSslPolicy.TLS_V1_1,
              cfr.OriginSslPolicy.TLS_V1_2,
            ],
          },
          behaviors: [
            {
              isDefaultBehavior: true,
              allowedMethods: cfr.CloudFrontAllowedMethods.ALL,
              cachedMethods: cfr.CloudFrontAllowedCachedMethods.GET_HEAD_OPTIONS,
              forwardedValues: { queryString: true, cookies: { forward: 'all' } },
            },
          ],
        },
      ],
    });

    /** @private */
    this._server = server;
    /** @private */
    this._cloudFront = cloudFront;
    /** @private */
    this._droneHomepage = cdk.Fn.conditionIf(
      new cdk.CfnCondition(this, 'DomainCondition', {
        expression: cdk.Fn.conditionEquals(props.parameters.ServerDomain, ''),
      }).logicalId,
      this._server.loadBalancer.loadBalancerDnsName,
      props.parameters.ServerDomain.valueAsString
    );

    // Drone server instances need to know their public DNS for callback URL generation
    server.taskDefinition.defaultContainer.props.environment.DRONE_SERVER_HOST = this._droneHomepage;
    server.taskDefinition.defaultContainer.props.environment.DRONE_SERVER_PROTO = 'https';
  }

  get httpHost() {
    return this._server.loadBalancer.loadBalancerDnsName;
  }

  get httpsHost() {
    return this._cloudFront.domainName;
  }

  get homepage() {
    return this._droneHomepage;
  }
}

module.exports = { DroneServer };
