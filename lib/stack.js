'use strict';

const assert = require('assert');
const s3 = require('@aws-cdk/aws-s3');
const cdk = require('@aws-cdk/core');
const iam = require('@aws-cdk/aws-iam');
const efs = require('@aws-cdk/aws-efs');
const rds = require('@aws-cdk/aws-rds');
const ec2 = require('@aws-cdk/aws-ec2');
const ecs = require('@aws-cdk/aws-ecs');
const cfr = require('@aws-cdk/aws-cloudfront');
const elb = require('@aws-cdk/aws-elasticloadbalancingv2');
const autoScaling = require('@aws-cdk/aws-autoscaling');
const ecsPatterns = require('@aws-cdk/aws-ecs-patterns');
const appAutoScaling = require('@aws-cdk/aws-applicationautoscaling');

const { Database } = require('./database');
const { Parameters } = require('./parameters');
const { Networking } = require('./networking');

class Stack extends cdk.Stack {
  constructor(scope, id, props) {
    super(scope, id, props);

    // These are JS config files turned into CloudFormation parameters
    const parameters = new Parameters(this);

    // Create a new VPC to house everything under
    const networking = new Networking(this, { parameters });

    // Create a serverless Aurora Postgres database
    const database = new Database(this, { networking, parameters });

    // IAM user used by Drone (does not support IAM roles yet)
    const logsBucketUser = new iam.User(this, 'LogsBucketUser');
    // Logs S3 bucket
    const logsBucket = new s3.Bucket(this, 'LogsBucket', {
      versioned: false,
      publicReadAccess: false,
      removalPolicy: cdk.RemovalPolicy.DESTROY,
      encryption: s3.BucketEncryption.KMS_MANAGED,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
    });
    // FIXME: Figure out what permissions Drone need and limit this
    const logsBucketResourcePolicy = new iam.PolicyStatement();
    logsBucketResourcePolicy.addResources(logsBucket.arnForObjects('*'), logsBucket.bucketArn);
    logsBucketResourcePolicy.addActions('s3:*');
    logsBucketResourcePolicy.effect = iam.Effect.ALLOW;
    logsBucketResourcePolicy.addArnPrincipal(logsBucketUser.userArn);
    logsBucket.addToResourcePolicy(logsBucketResourcePolicy);

    // Create a set of IAM credentials for Drone (does not support IAM roles yet)
    const logsBucketCredentials = new iam.CfnAccessKey(this, 'LogsBucketCredentials', {
      userName: logsBucketUser.userName,
    });
    const logsAccessKey = logsBucketCredentials.ref;
    const logsSecretKey = logsBucketCredentials.attrSecretAccessKey;

    // Fleet of server instances, running on Fargate
    const server = new ecsPatterns.ApplicationLoadBalancedFargateService(this, 'ServerAgents', {
      cluster: networking.cluster,
      publicLoadBalancer: true,
      taskImageOptions: {
        image: ecs.ContainerImage.fromRegistry(parameters.ServerContainer.valueAsString),
        environment: {
          AWS_ACCESS_KEY_ID: logsAccessKey,
          AWS_SECRET_ACCESS_KEY: logsSecretKey,
          AWS_DEFAULT_REGION: this.region,
          AWS_REGION: this.region,
          DRONE_S3_BUCKET: logsBucket.bucketName,
          DRONE_LOGS_DEBUG: 'true',
          DRONE_LOGS_COLOR: 'false',
          DRONE_AGENTS_ENABLED: 'true',
          DRONE_REPOSITORY_FILTER: parameters.ServerRepoFilter,
          DRONE_GITHUB_SERVER: parameters.GithubServer,
          DRONE_GITHUB_CLIENT_ID: parameters.GithubClientId,
          DRONE_GITHUB_CLIENT_SECRET: parameters.GithubClientSecret,
          DRONE_RPC_SECRET: parameters.ServerRpcSecret,
          DRONE_DATABASE_DRIVER: 'postgres',
          DRONE_DATABASE_SECRET: parameters.DatabaseSecret,
          DRONE_DATABASE_DATASOURCE: cdk.Fn.sub('postgres://${user}:${pass}@${host}:${port}/drone?sslmode=disable', {
            user: parameters.DatabaseUsername,
            pass: parameters.DatabasePassword,
            host: database.host,
            port: database.port,
          }),
          DRONE_COOKIE_SECRET: parameters.ServerCookieSecret,
          DRONE_USER_CREATE: cdk.Fn.sub('username:${admin},admin:true', {
            admin: parameters.ServerAdmin,
          }),
        },
      },
    });

    // Scale server based on 90% cpu utilization
    server.service
      .autoScaleTaskCount({ maxCapacity: parameters.ServerMaxCapacity })
      .scaleOnCpuUtilization('ServerCPUScaling', {
        targetUtilizationPercent: 90,
        scaleInCooldown: cdk.Duration.minutes(1),
        scaleOutCooldown: cdk.Duration.minutes(1),
      });

    // We don't need CfnOutputs generated by this construct
    server.node.applyAspect(new RemoveConstructsWithPredicate(node => node instanceof cdk.CfnOutput));

    // Put CloudFront in front of Drone to add HTTPS to it and cache its frontend files
    const cloudFront = new cfr.CloudFrontWebDistribution(this, 'CloudfrontWrapper', {
      viewerProtocolPolicy: cfr.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
      originConfigs: [
        {
          customOriginSource: {
            domainName: server.loadBalancer.loadBalancerDnsName,
            originProtocolPolicy: cfr.OriginProtocolPolicy.HTTP_ONLY,
            allowedOriginSSLVersions: [
              cfr.OriginSslPolicy.TLS_V1,
              cfr.OriginSslPolicy.TLS_V1_1,
              cfr.OriginSslPolicy.TLS_V1_2,
            ],
          },
          behaviors: [
            {
              isDefaultBehavior: true,
              allowedMethods: cfr.CloudFrontAllowedMethods.ALL,
              cachedMethods: cfr.CloudFrontAllowedCachedMethods.GET_HEAD_OPTIONS,
              forwardedValues: { queryString: true, cookies: { forward: 'all' } },
            },
          ],
        },
      ],
    });

    // Drone server instances need to know their public DNS for callback URL generation
    server.taskDefinition.defaultContainer.props.environment.DRONE_SERVER_HOST = cloudFront.domainName;
    server.taskDefinition.defaultContainer.props.environment.DRONE_SERVER_PROTO = 'https';

    // Drone's docker runner need access to the docker socket, therefore cannot be in
    // a Fargate task definition. We launch our runners inside classic EC2 instances.
    const runner = new ecsPatterns.ApplicationLoadBalancedEc2Service(this, 'RunnerAgents', {
      cluster: networking.cluster,
      publicLoadBalancer: false,
      memoryReservationMiB: 512,
      taskImageOptions: {
        image: ecs.ContainerImage.fromRegistry(parameters.RunnerContainer),
        environment: {
          DRONE_DEBUG: 'true',
          DRONE_TRACE: 'true',
          DRONE_RUNNER_CAPACITY: parameters.RunnerJobCapacity,
          DRONE_RPC_HOST: server.loadBalancer.loadBalancerDnsName,
          DRONE_RPC_PROTO: 'http',
          DRONE_RPC_SECRET: parameters.ServerRpcSecret,
        },
      },
    });

    // We don't need a load balancer in front of runners agents
    runner.node.applyAspect(
      new RemoveConstructsWithPredicate(
        node =>
          node instanceof elb.CfnLoadBalancer || node instanceof elb.CfnListener || node instanceof elb.CfnTargetGroup
      )
    );
    runner.node.applyAspect({
      visit: node => {
        if (node instanceof ecs.CfnService) {
          node.addOverride('Properties.LoadBalancers');
          node.addOverride('Properties.HealthCheckGracePeriodSeconds');
        }
      },
    });
    // We don't need CfnOutputs generated by this construct
    runner.node.applyAspect(new RemoveConstructsWithPredicate(node => node instanceof cdk.CfnOutput));

    // Mount docker socket inside runner containers
    runner.taskDefinition.addVolume({
      host: { sourcePath: '/var/run/docker.sock' },
      name: 'docker-sock',
    });
    runner.taskDefinition.defaultContainer.addMountPoints({
      sourceVolume: 'docker-sock',
      containerPath: '/var/run/docker.sock',
      readOnly: false,
    });

    // Scale runner based on 90% cpu utilization
    runner.service
      .autoScaleTaskCount({ maxCapacity: parameters.RunnerMaxCapacity })
      .scaleOnCpuUtilization('RunnerCPUScaling', {
        targetUtilizationPercent: 90,
        scaleInCooldown: cdk.Duration.minutes(1),
        scaleOutCooldown: cdk.Duration.minutes(1),
      });

    // Create a persistent EFS volume for build caching
    const cacheVolume = new efs.CfnFileSystem(this, 'EFSCacheVolume', {
      performanceMode: 'generalPurpose',
      throughputMode: 'bursting',
      lifecyclePolicies: [{ transitionToIa: 'AFTER_14_DAYS' }],
    });

    // Create a security group that opens up the database to our subnet
    const efsSecurityGroup = new ec2.SecurityGroup(this, 'EFSSecurityGroup', {
      allowAllOutbound: true,
      vpc: networking.vpc,
    });
    efsSecurityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(2049)); // 2049 is the port for NFS
    efsSecurityGroup.addIngressRule(ec2.Peer.anyIpv6(), ec2.Port.tcp(2049)); // 2049 is the port for NFS

    // create a persistent EFS volume for Drone's cache
    networking.vpc.privateSubnets.forEach((subnet, index) => {
      new efs.CfnMountTarget(this, `EFSMountTarget${index}`, {
        fileSystemId: cacheVolume.ref,
        subnetId: subnet.subnetId,
        securityGroups: [efsSecurityGroup.securityGroupId],
      });
    });

    // Create a cleaner task that cleans the EFS volume to reduce costs
    const cleaner = new ecsPatterns.ScheduledEc2Task(this, 'CleanerAgent', {
      cluster: networking.cluster,
      desiredTaskCount: 1,
      schedule: appAutoScaling.Schedule.expression(cdk.Fn.sub('rate(${rate})', { rate: parameters.CacheCleanerRate })),
      scheduledEc2TaskImageOptions: {
        image: ecs.ContainerImage.fromRegistry('alpine'),
        memoryReservationMiB: 512,
        command: [
          'sh',
          '-c',
          cdk.Fn.sub('find /cache -mtime +${expiry} -exec rm -f {} \\;', { expiry: parameters.CacheExpireAfter }),
        ],
      },
    });
    // Mount cache volume inside cleaner containers
    cleaner.taskDefinition.addVolume({
      host: { sourcePath: '/mnt/efs' },
      name: 'efs-cache',
    });
    cleaner.taskDefinition.defaultContainer.addMountPoints({
      sourceVolume: 'efs-cache',
      containerPath: '/cache',
      readOnly: false,
    });

    // Inject EFS into Runner ECS Container Instances
    networking.cluster.node.applyAspect(new InjectEfsIntoContainerInstance(cacheVolume.ref));

    // Output server's address
    const host = cloudFront.domainName;
    new cdk.CfnOutput(this, 'DroneHost', { value: host });
    new cdk.CfnOutput(this, 'DroneHomepage', { value: cdk.Fn.sub('https://${host}', { host }) });
    new cdk.CfnOutput(this, 'OAuthCallback', { value: cdk.Fn.sub('https://${host}/login', { host }) });
  }
}

/** A CDK Aspect that removes node when passed predicate return true */
class RemoveConstructsWithPredicate {
  constructor(predicate = () => false) {
    this._predicate = predicate;
  }
  visit(node) {
    if (this._predicate(node)) {
      const pathComponents = node.node.path.split(cdk.ConstructNode.PATH_SEP);
      assert.ok(pathComponents.length >= 2, 'invalid construct path found');
      assert.ok(pathComponents.shift() === node.stack.stackName);
      const connector = '.node._children.';
      eval(`delete node.stack${connector}${pathComponents.join(connector)}`);
    }
  }
}

/** This is a CDK Aspect that injects EFS into ECS Container Instance userData scripts */
class InjectEfsIntoContainerInstance {
  constructor(efs) {
    this._efs = efs;
  }
  visit(node) {
    if (node instanceof autoScaling.AutoScalingGroup) {
      // mount our EFS file system on boot
      // see: https://aws.amazon.com/premiumsupport/knowledge-center/ecs-create-docker-volume-efs/
      const mountOpts = 'nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2,noresvport';
      const mountDest = '/mnt/efs';
      node.addUserData([
        'yum update -y',
        'yum install -y amazon-efs-utils',
        `mkdir -p ${mountDest}`,
        cdk.Fn.sub(`mount -t nfs4 -o ${mountOpts} \${efsId}.efs.\${region}.amazonaws.com:/ ${mountDest}`, {
          region: node.stack.region,
          efsId: this._efs,
        }),
        `chmod 777 ${mountDest}`,
        'mount -a',
      ]);
    }
  }
}

module.exports = { Stack };
